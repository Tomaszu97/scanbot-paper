\chapter{Ewaluacja}

\section{Odometria}
\label{sec:odometry}
Robot korzysta z nawigacji zliczeniowej w celu połączenia pomiarów odległości zebranych z otoczenia i aproksymacji ich położenia na płaszczyźnie względem jednego ustalonego punktu. Zliczaniu podlegają dwie wartości - dystans przejechany wzdłuż oraz obrót pojazdu w miejscu. Szereg zmierzonych w ten sposób wartości umożliwia odtworzenie przejechanej ścieżki. Rysunek \ref{fig:odom-axis-simplified} przedstawia rzeczywisty oraz uproszczony model podwozia robota. X na rysunku oznacza środek robota - pionową oś wokół której się obraca. Zamiast uwzględniać obie poziome osi i 4 koła, upraszcza się go do formy robota o jednej osi, z jedną parą kół. Gdy oba koła poruszają się w tę samą stronę, robot przesuwa się w przód lub w tył. Gdy pracują przeciwbieżnie - obraca się wokół osi oznaczonej X.  

\begin{figure}[H]
	\centering
		\includegraphics[width=0.8\linewidth]{rys/robot-odometry-simplified.png}
	\caption{Model rzeczywisty i uproszczony }
	\label{fig:odom-axis-simplified}
\end{figure}


Pierwszym pomysłem było wykorzystanie enkoderów do pomiaru translacji pojazdu wzdłuż jego osi ruchu, pozostawiając zliczanie obrotu funkcjom korzystającym z magnetometru.

\begin{figure}[H]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/encoder-position.png}
	\caption{Umiejscowienie enkodera z prawej strony robota}
	\label{fig:encoder-pos}
\end{figure}

Enkodery zostały zamontowane w miejscu przedstawionym na rysunek \ref{fig:encoder-pos}, symetrycznie po obu stronach podwozia. Napęd podany od serwa przez zębatkę przenosi napęd zarówno na tylne koło jak i enkoder, z przekładniami 1:1 w obu przypadkach. Dzięki takiemu rozwiązaniu pełny obrót enkodera odpowiada pełnemu obrotowi koła. Enkoder obrotowy EC-11 generuje 20 impulsów przy kącie obrotu 360°. Aby można było wyznaczyć pokonaną odległość, w pierwszej kolejnosci należy obliczyć stosunek ilości impulsów do przejechanego dystansu - w tym celu autor stworzył prosty wzór:

\begin{center}
    $DPR = \frac{2 \pi r}{p}$ \\[5pt]
    \emph{DPR - współczynnik (ang. Distance to Pulse Ratio) wyrażany w cm/impuls} \\[5pt]
    \emph{r - promień koła pojazdu} \\[5pt]
    \emph{p - liczba impulsów enkodera na obrót koła}
\end{center}

Wiedząc ile impulsów generuje enkoder, oraz znając wymiary koła w łatwy sposób można obliczyć DPR. Podstawiając dane to jest:

\begin{center}
    $DPR = \frac{2 \pi 2,5cm}{20imp}$ \\[5pt]
    $DPR = 0.785 \frac{cm}{imp}$ \\[5pt]
    $\frac{1}{DPR} = 1.274$
\end{center}

Znając współczynnik aby obliczyć przejechany dystans wystarczy zmierzyć ilość impulsów jakie wystąpiły podczas przejazdu a następnie pomnmożyć je przez DPR. Otrzymany wynik oznacza przesunięcie robota wyrażone w centymetrach. Jako że platforma posiada dwa enkodery, a nie jest możliwe zachowanie idealnie prostego toru jazdy, wyciągana jest średnia liczba impulsów. Ze względu na grubość i wypustki na gąsienicach oraz ich poślizg rzeczywisty dystans przejechany będzie inny od zadanego. Dla kompensacji tej różnicy wartość DPR została skorygowana ręcznie do takiej, przy której błąd przemieszczenia robota zawierał się w granicy ±10\% na zadanym dystansie 100cm. Widoczna w kodzie programu, skorygowana wartość $\frac{1}{DPR}$ wynosi $1.325$ co odpowiada $DPR=0.755$ . Listing \ref{lst:move} prezentuje funkcję realizującą to zadanie.


\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,language=c++,caption=Fragment kodu obsługującego polecenie \emph{MOVE},label=lst:move]
//MOVE
case 9:
{
    reset_encoders();
    float val = getArgument(command, 1).toInt() * 1.325;

    if (val > 0)
        driveMotors(90, 90);
    else
        driveMotors(-90, -90);

    val = abs(val);
    while ((left_encoder_counter + right_encoder_counter) / 2 < val)
    {
    }

    driveMotors(0, 0);
    delay(100);
    Serial2.println("OK");
}
\end{lstlisting}

Podczas wykonywania polecenia \emph{MOVE} na gąsienice zadawana jest pełna prędkość i w pętli sprawdzana jest średnia ilość impulsów wygenerowanych przez enkoder. Dla optymalizacji algorytmu, zamiast przeliczać przy każdym pomiarze ilość impulsów razy wartość DPR, na początku zadana w parametrze wartość odległości jest mnożona przez $\frac{1}{DPR}$, i dalej w takiej formie ta wartość wykorzystywana przy operacji porównania. W momencie w którym średnia zliczona ilość impulsów przekroczy jej wartość, serwa zostają zatrzymane.
\\ 

Obrót (funkcja \emph{ROTATE}) polega na zadaniu przeciwstawnych wartości prędkości na obie gąsienice. W celu obrotu poruszają się one przeciwbieżnie, z równymi prędkościami. Pierwsza implementacja funkcji obrotu wyglądała jak przedstawiono poniżej:

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,language=c++,caption=Funkcja będąca głównym elementem obsługi poleceń \emph{ROTATE} oraz \emph{ROTATE\_TO},label=lst:rotate-to-function]
void rotateTo(int azimuth)
{
    if (calcAngleDistance(getAzimuth(), azimuth) > 0)
        driveMotors(-90, 90);
    else
        driveMotors(90, -90);

    while (true)
    {
        if (abs(calcAngleDistance(getAzimuth(), azimuth)) <= 10)
            break;
        delay(10);
    }
    driveMotors(0, 0);
    delay(100);
}
\end{lstlisting}

Na początku mierzony jest azymut początkowy i obliczany jest azymut końcowy (tj. początkowy + zadana wartość obrotu). Dalej wykonywana jest ta sama funkcja co w przypadku \emph{ROTATE\_TO} przyjmująca parametr azymutu końcowego. Podczas obrotu, w pętli, sprawdzana jest różnica kąta aktualnego od zadanego. Jeżeli wartość bezwzględna obrotu znajdzie się w zakresie ±10° robot zatrzyma się.

Takie rozwiązanie jest dobre, o ile magnetometr jest skalibrowany i funkcjonuje poprawnie. Niestety, podczas skanów okazało się że nie można polegać na pomiarach z tego sensora - więcej o tym znajduje się w sekcji \ref{sec:scan}. Z tego powodu koniecznym okazała się zmiana podejścia do pomiaru obrotu.

Listing \ref{lst:rotate} przedstawia nowe podejście osbługi polecenia \emph{ROTATE}. Jest ono mniej dokładne od poprzedniego, bardziej podatne na dryf (błąd obrotu kumuluje się), natomiast taki pomiar jest odporny na zakłócenia pola magnetycznego.
Tym razem procedura jest analogiczna jak w przypadku ewaluacji polecenia \emph{MOVE}. W pętli sprawdzana jest średnia ilość impulsów, jednak tym razem gąsienice poruszają się przeciwbieżnie. Kąt obrotu na początku należy przemnożyć przez pewien współczynnik tak aby odpowiadał on ilości impulsów. Platforma kończy ruch w momencie gdy średnia wartość przekroczy obliczony próg impulsów.

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,language=c++,caption=Nowa implementacja obsługi polecenia \emph{ROTATE},label=lst:rotate]
// ROTATE
    case 11:
    {
        reset_encoders();
        float val = getArgument(command, 1).toInt() * 0.164;
        if (val > 0)
            driveMotors(-90, 90);
        else
            driveMotors(90, -90);

        val = abs(val);
        while ((left_encoder_counter + right_encoder_counter) / 2 < val)
        {
        }

        delay(100);
        driveMotors(0, 0);
        Serial2.println("OK");
    }
    break;
\end{lstlisting}

Stosunek kąta obrotu do liczby impulsów ($0.164$) został wyznaczony eksperymentalnie. Najpierw przyjęto wartość 1. Następnie zadawany był kąt obrotu 90°, po czym mierzony był rzeczywisty kąt obrotu. Jeżeli wynosił on więcej, współczynnik redukowano o 0,1; analogicznie gdy obrót był mniejszy niż zadano. Gdy tak zgrubna regulacja była niewystarczająca (albo za mały albo za duży obrót), krok został zmniejszony do 0,05. Po kolejnej zmianie kroku do 0,02 czynność powtarzano do momentu w którym dalsza korekcja nie była konieczna. \\

Taka implementacja została zachowana do końca projektu. Polecenie \emph{ROTATE\_TO} dalej korzysta ze starego sposobu z użyciem magnetometru, jednak nie jest ono wykorzystywane podczas pomiarów.

\subsection{Kalibracja magnetometru}
%>TODO przypis o zakloceniach i ich zrodlach
Wykorzystywany w projekcie moduł magnetometru jest urządzeniem czułym i bardzo podatnym na zakłócenia - szczególnie jeśli mierzone jest pole magnetyczne ziemi. Poza zakłóceniami z otoczenia, występują również te wynikające z samej budowy robota - wszelkie przewody przez które płynie prąd generują swoje własne pola, nawet same metalowe elementy interferują z pomiarem. Na te zakłócenia należy zwrócić uwagę i podjąć kroki mające na celu ich kompensację. Warto też wspomnieć, że w tej pracy jednostki uzyskane z pomiaru nie mają znaczenia - jedyne co jest potrzebne w celu uzyskania informacji o kierunku w którym robot jest zwrócony to kierunek i zwrot zmierzonego wektora wartości natężenia pola.

Pierwszym problemem są zakłócenia typu \emph{hard iron}. Ich obecność przejawia się w postaci stałego przesunięcia mierzonych we wszystkich trzech osiach wartości natężenia pola magnetycznego. Zmierzone wartości można przedstawić na trójwymiarowym wykresie (jak uczyniono w pierwszych wersjach aplikacji sterującej). Każda z osi wykresu odpowiada osi pomiaru natężenia pola magnetycznego. W idealnej sytuacji zbór punktów powinien być osadzony na sferze o środku w punkcie $(0,0,0)$. Tak się jednak nie dzieje, co jest widoczne na rysunku \ref{fig:3d-mag-no-cal}.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-03-magnetometer-3d-decalibrated.PNG}
	\caption{Wykres obrazujący dane pozyskane z nieskalibrowanego magnetometru}
	\label{fig:3d-mag-no-cal}
\end{figure}

Aby dokonać korekcji \emph{hard iron} \cite{hard-iron}\cite{hard-soft-iron} dla każdej osi z osobna należy wyznaczyć minimalną i maksymalną zmierzoną wartość. Sumę obu wartości dzieli się przez 2, a uzyskana liczba to przesunięcie (ang. \emph{offset}). Aplikacja korekcji polega na odjęciu tej liczby od zmierzonej wartości.
Tą procedurę dla trzech osi przedstawiają kolejno rysunki \ref{fig:3d-mag-hard-corr-x}, \ref{fig:3d-mag-hard-corr-y} i \ref{fig:3d-mag-hard-corr-z}.

\begin{figure}[H]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-04-magnetometer-3d-calibration.PNG}
	\caption{Korekta przesunięcia \emph{hard iron} dla osi X}
	\label{fig:3d-mag-hard-corr-x}
\end{figure}

\begin{figure}[H]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-05-magnetometer-3d-calibration.PNG}
	\caption{Korekta przesunięcia \emph{hard iron} dla osi Y}
	\label{fig:3d-mag-hard-corr-y}
\end{figure}

\begin{figure}[H]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-06-magnetometer-3d-calibration.PNG}
	\caption{Korekta przesunięcia \emph{hard iron} dla osi Z}
	\label{fig:3d-mag-hard-corr-z}
\end{figure}

Niestety, kształt chmury punktów wciąż daleki jest od idealnej sfery. Efektem tego jest nieliniowość uzyskanego azymutu - zmiana rzeczywistego kąta skierowania platformy względem zmiany zmierzonej będzie się znacząco różniła w zależności od początkowej pozycji. Ten efekt można by obejść za pomocą mapowania wartości przepuszczając odczyt przez funkcję odpowiedniej krzywej, jednak wymagałoby to formułowania skomplikowanego równania, bądź wyznaczenia arbitralnego przebiegu funkcji. Istnieje jednak mniej wymagające obliczeniowo podejście z zastosowaniem macierzy \cite{hard-soft-iron}. Dla uproszczenia obliczeń, zrezygnowano z pomiaru w trzech osiach, zamiast tego mierzone są jedynie natężenia pola w osiach X i Y (rysunek \ref{fig:2d-mag-no-cal}).

\begin{figure}[H]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-08-2d-calibration-theta-sigma.PNG}
	\caption{Rozkalibrowany magnetometr na dwuwymiarowej płaszczyźnie}
	\label{fig:2d-mag-no-cal}
\end{figure}

Tak jak w przypadku trzech wymiarów, w pierwszej kolejności dokonywana jest korekcja zniekształceń \emph{hard iron} na wszystkich osiach (rysunek \ref{fig:2d-mag-hard-corr-xy}).

\begin{figure}[H]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-10-2d-calibration-theta-sigma-2-added-hard-offset-reset-data-so-soft-iron-values-are-proper.PNG}
	\caption{Korekcja hard iron}
	\label{fig:2d-mag-hard-corr-xy}
\end{figure}


Teraz można przystąpić do procedury kompensacji zniekształceń \emph{soft iron}. Idealnie, po dokonaniu korekcji w dwóch wymiarach, punkty na wykresie można by umieścić na okręgu - tak jednak nie jest. Uzyskany kształt bardziej przypomina elipsę, i ta właściwość zostanie wykorzystana. Proces przebiega w kilku krokach:

\begin{enumerate}
    \item Dla każdego z punktów liczony jest promień $r$ (wektor od $(0,0)$ do danego punktu)
    \item Wyznaczana jest maksymalna wartość promienia $rmin$ i $rmax$. Te wartości odpowiadają kolejno półosi małej i półosi wielkiej elipsy.
    \item Dla punktu odpowiadającego promieniowi $rmax$ Obliczany jest kąt $\theta$ za pomocą dwuargumentowej funkcji $arctan2(y,x)$, gdzie $x$ i $y$ są współrzędnymi punktu. Kąt ten odpowiada kątowi obrotu elipsy.
    \item Tworzona jest macierz $R$. Posłuży do obrotu elipsy.
    $R = \begin{bmatrix}
            cos\theta & sin\theta\\
            -sin\theta & cos\theta
        \end{bmatrix}$
    \item Obliczany jest parametr $\sigma$. Posłuży do ściskania elipsy. $\sigma = \frac{rmin}{rmax}$
    \item Za pomocą macierzy $R$ elipsa jest obracana o kąt -$\theta$ w celu zrównania jej wielkiej półosi z osią OX układu współrzędnych. Współrzędne każdego z punktów kolejno są osobno przekształcane za pomocą mnożenia macierzy:
    $   
        \mathit{v}_{2}
        =
        \begin{bmatrix}
            cos\theta & sin\theta\\
            -sin\theta & cos\theta
        \end{bmatrix}
        \times
        \begin{bmatrix}
            \mathit{v}_{1x}\\
            \mathit{v}_{1y}
        \end{bmatrix}
    $
    gdzie $\mathit{v}_{2}$ to wynikowy wektor zawierający współrzędne przekształconego punktu.
    \item Obróconą elipsę sprowadza się do postaci okręgu poprzez ściśnięcie jej w osi X. Robi się to przemnażając współrzędną x każdego z punktów osobno przez wcześniej obliczony parametr: $\mathit{v}_{2x} = \mathit{v}_{1x} \times \sigma$
\end{enumerate}

Ostatecznie chmura punktów tworzy okrąg co przedstawiono na rysunku \ref{fig:2d-mag-soft-corr-applied}. Efektem zastosowania kalibracji jest równomierny odczyt azymutu wraz z obrotem platformy. Każdy zmierzony i przefitrowany punkt może być teraz przeliczony na kąt wektora, który wskazuje azymut - wystarczy skorzystać z dwuargumentowej funkcji $arctan2(x,y)$, gdzie $x$ i $y$ są współrzędnymi punktu.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-11-2d-set-theta-then-sigma-and-done.PNG}
	\caption{Chmura punktów po dokonaniu korekcji obu typów zniekształceń}
	\label{fig:2d-mag-soft-corr-applied}
\end{figure}

Finalna wersja aplikacji korzysta z dwóch osi magnetometru. W celu kalibracji należy skorzystać z zakładki \emph{magnetometer calibration} głównego okna aplikacji sterującej. Rysunek \ref{fig:main-app-mag-section-bottom} przedstawia najważniejsze elementy tej zakładki, wykorzystywane podczas półautomatycznego procesu kalibracji.

\begin{figure}[ht]
	\centering
		\includegraphics[width=1\linewidth]{rys/main-app-view-magnetom-bottom.png}
	\caption{Najważniejsze elementy sekcji kalibracji}
	\label{fig:main-app-mag-section-bottom}
\end{figure}

Aby dokonać kalibracji, robot powinien być połączony z aplikacją sterującą. Dalej procedura przebiega jak następuje:

\begin{enumerate}
    \item Należy przejśćdo zakładki \emph{magnetometer calibration}
    \item Jeżeli na wykresie znajdują się poprzednie pomiary, należy kliknąć przycisk \emph{CLEAR GRAPH DATA} aby je usunąć
    \item Należy wyzerować dane kalibracyjne znajdujące się w pamięci EEPROM robota. Służy do tego przycisk \emph{SEND CLEAR CALIBRATION DATA}
    \item Na tym etapie istnieją dwie możliwości przeprowadzenia pomiaru - za pomocą przycisku \emph{MEASURE [AUTO]} platforma samodzielnie, krokowo, wykona obrót wokół własnej osi i zbierze serię pomiarów z magnetometru; za pomocą przycisku \emph{MEASURE [MANUAL]} dokona jedynie pomiarów, w tym czasie należy robota obracać ręcznie. Postęp pomiarów wizualizowany jest na pasku postępu w prawym dolnym rogu. Na wykresie pojawią się zebrane pomiary. W sekcji oznaczonej \emph{HARD IRON CORRECTION} pojawiać się będą uzyskane dane dotyczące korekcji pierwszego z omawianych wcześniej zaburzeń - wartości minimalne i maksymalne dla każdej z osi oraz wartość przesunięcia (\emph{OFFSET}). W sekcji \emph{SOFT IRON CORRECTION} pojawiać się będą cyklicznie przeliczane wartości dotyczące korekcji zaburzeń \emph{soft iron} - m.in. parametry $\theta$ $\sigma$ i wartości macierzy $R$.
    \item Za pomocą przycisku \emph{CORRECT HARD IRON OFFSET} należy dokonać korekcji zaburzeń typu \emph{hard iron} na podstawie obliczonych wartości przesunięcia. Efekt natychmiastowo ukaże się na wykresie.
    \item Za pomocą przycisku \emph{CORRECT SOFT IRON OFFSET} należy dokonać korekcji zaburzeń typu \emph{soft iron}. Dane również brane są z obliczonych podczas procedury pomiaru. W tym momencie punkty na wykresie powinny być ułożone w okrąg. Jeżeli jest inaczej, oznacza to że w otoczeniu występują zaburzenia pola magnetycznego. Wtedy należy przemieścić robota w inne miejsce i powtórzyć wymienione czynności od nowa.
    \item Na koniec, aby wysłać dane kalibracyjne do robota, należy kliknąć przycisk \emph{SEND CALCULATED CALIBRATION DATA}. 
\end{enumerate}

Po dokonaniu procedury kalibracji pomiary dużo lepiej oddają rzeczywisty kierunek i zwrot platformy, jednak nawet podczas postoju platformy zwracana wartość azymutu nie pozostaje stała. Aby zniwelować to zjawisko konieczne jest zastosowanie filtru.

\subsection{Filtr Kalmana}
W układach sensorycznych robotów powszechnie wykorzytywany jest filtr Kalmana\cite{Kedzierski2016}. W tej sekcji wyjaśniona będzie zastosowana w projekcie, uproszczona implementacja takiego filtru.

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,language=python,caption=Implementacja filtru Kalmana w języku Python,label=lst:kalman]
def get_azimuth_kalman(self):
    q = 0.1
    estimate_err = 3
    measure_err = 3
    last_est = int(self.send("GET_AZIMUTH#"))

    for _ in range(20):
        measurement = int(self.send("GET_AZIMUTH#"))
        kalman_gain = estimate_err/(estimate_err + measure_err)
        current_est = last_est + kalman_gain*(measurement - last_est)
        estimate_err = (1 - kalman_gain)*estimate_err + abs(last_est-current_est)*q
        last_est = current_est
        ... (pominięto)
        
    current_est = int(current_est)
    self.azimuth = current_est
    self.publish_ros_odometry()
    return self.azimuth
\end{lstlisting}

Ze względu na ograniczone zasoby mikrokontrolera, filtracja odbywa się po stronie aplikacji sterującej. Pomiar dokonywany jest podczas gdy platforma stoi nieruchomo, stąd wiadomo że estymowana wartość jest stała. Na początku potrzebne będzie kilka odgórnie ustalonych parametrów. Wartości \emph{estimate\_err} i \emph{measure\_err} odpowiadają kolejno wariancji estymatora i wariancji mierzonej wartości (normalnie wyznaczone na podstawie dokładności pomiaru przyrządu), jednak nie muszą one być ustalone na podstawie rzeczywistych parametrów urządzenia. Ich wartości będą wpływać na działanie filtru - to czy dane będą bardziej "wygładzane", czy bardziej zależne od ostatniego pomiaru. W tym wypadku zostały wyznaczone eksperymentalnie. Parametr \emph{q} nie był konieczny, służy on regulacji zwiększenia wariancji estymaty w przypadku gdy estymowana wartość jest zmienna w czasie. Został on również dobrany eksperymentalnie. Chociaż ma mały wpływ na pomiary statyczne - jest zaimplementowany na potrzeby przyszłego rozwoju projektu.

Kolejną rzeczą która jest potrzebna jest aktualna wartość ostatniej estymacji \emph{last\_estimate}. Przy odpowiednio długim pomiarze tę wartość można ustawić na dowolną, jednak aby wartość estymatora szybciej zbiegała do estymowanej wstępnie zostaje ustawiona na zmierzoną wartość.

Mając wszystkie parametry można przystąpić do uruchomienia filtru. Przebiega on w 20 iteracjach. W każdej z iteracji zachodzą dwie fazy - predykcji i korekcji.
\\

Faza predykcji polega na wyznaczeniu wartości oczekiwanej apriori $\hat{x}(t+1)^-$ i odchylenia standardowego apriori $\sigma^2(t+1)^-$ dla czasu $t+1$ na podstawie analogicznych wartości aposteriori dla czasu $t$, tj.  $\hat{x}(t)^+$ i $\sigma^2(t)^+$. W tym wypadku z założenia wartość mierzona jest stała, dlatego przyjmuje się że:
\begin{center}
    $\hat{x}(t+1)^- = \hat{x}(t)^+$ \\[5pt]
    $\sigma^2(t+1)^- = \sigma^2(t)^+$.    
\end{center}
Kod programu korzysta ze zmiennych \emph{est\_error} i \emph{current\_est}. Wartości apriori i aposteriori nie muszą być trzymane jednocześnie w pamięci - wystarczy nadpisywać stare zmienne. Tutaj oznaczałoby to sformułowanie konstrukcji \emph{est\_error}=\emph{est\_error} i \emph{current\_est}=\emph{current\_est} co nie jest potrzebne i dlatego zostało pominięte.
\\

Faza korekcji odbywa się w pętli. Najpierw dokonywany jest pomiar z sensora (\emph{measurement}). Następnie obliczane jest wzmocnienie Kalmana (\emph{kalman\_gain}), czyli parametr wpływający na to jakie znaczenie nowy pomiar ma dla wartości estymatora oraz jego wariancji. Później, z jego wykorzystaniem obliczana jest nowa wartość estymatora (\emph{current\_est}). W kolejnej linijce aktualizowana jest wartość jego wariancji (\emph{estimate\_err}). Aktualnie wraz z każdym nowym przejściem pętli zbiega ona do niezerowej wartości, zależnej od parametru q. Gdyby ten parametr nie zaistniał, z każdą iteracją jej wartość zbiegałaby do zera. Na koniec wartość (\emph{current\_est}) kopiowana jest do (\emph{last\_est}). Dzieje się to, ponieważ aktualizacja (\emph{estimate\_err}) potrzebuje przy obliczeniach wartości aktualnej oraz poprzedniej estymatora.

Po dwudziestokrotnym przejściu, wartość oczekiwana estymatora konwertowana jest na liczbę całkowitą, i zapisywanam, dane o azymucie są publikowane na odpowiednim temacie i wartość jest zwracana przez funkcję.

\subsection{Poprawa jakości odometrii}
Ze względu na brak możliwości skonstruowania idealnego obiektu rzeczywisty ruch platformy nie pokrywa się z zamierzonym. Oś obrotu kół nigdy nie osiągnie wymiarów idealnie równych z projektem, podobnie same koła będą miały inne i różne od siebie średnice (oczywiście, z pewnym przybliżeniem mówi się że są one ``równe``). Dodatkowo na nieidealny tor ruchu wpływa chropowatość powierzchni, drgania styków enkoderów i wiele innych czynników. Istnieje metoda która pozwala skorygować część z wymienionych czynników.
\\

Wykorzystana zostanie metoda korekcji opisana w pracy \emph{Correction of Systematic Odometry Errors in Mobile Robots}\cite{Borenstein1995}. Korzysta ona z metody wyznaczania błędu przejazdu trasy zwanej \emph{UMBmark} (od ang. \emph{University of Michigan Benchmark}). Polega ona na zbadaniu przesunięcia pozycji końcowej robota względem pozycji początkowej po pokonaniu wyznaczonej, kwadratowej ścieżki. Na rysunku \ref{fig:umbenchmark-path} przedstawiono przykładowy przejazd w kierunku przeciwnym do ruchu wskazówek zegara.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.8\linewidth]{rys/umbenchmark-path.pdf}
	\caption{Trasa przejazdu robota według \emph{UMBmark}}
	\label{fig:umbenchmark-path}
\end{figure}

Metoda \emph{UMBmark} polega na pięciokrotnym pomiarze błędów $\in{x}$ oraz $\in{y}$ po przejazdach zgodnie i przeciwnie do ruchu wskazówek zegara. Różne kierunki przejazdu pomogą zniwelować wpływ błędów niesystematycznych na tor jazdy platformy. Rozmiar kwadratowej ścieżki według dokumentu powinien wynosić $4\times4$ metry ($L=4m$), jednak ze względu na ograniczoną przestrzeń autor zmniejszył obszar do rozmiaru $1,5\times1,5$ metra. Zdjęcia środowiska testowego przedstawiono na rys. \ref{fig:umbenchmark-photo-path} i  \ref{fig:umbenchmark-photo-finish}. Do pomiarów użyto taśmy mierniczej zwijanej o dokładności ±1 mm jednak ze względów praktycznych w pomiarach uwzględniono wartości zaokrąglone do pełnych centymetrów. Wyniki przedstawiono w tabeli \ref{tab:umbmark}.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/UMBenchmark-1.jpg}
	\caption{Wyznaczona ścieżka przejazdu robota}
    \label{fig:umbenchmark-photo-path}
\end{figure}

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/UMBenchmark-2.jpg}
	\caption{Punkt startowy i przesunięcie}
    \label{fig:umbenchmark-photo-finish}
\end{figure}


\begin{table}[H]
    \caption{Wyniki pomiarów \emph{UMBmark}}
     \label{tab:umbmark}
    \centering
    \begin{tabular}{ |p{0.05\linewidth}|p{0.15\linewidth}|p{0.15\linewidth}|p{0.15\linewidth}|p{0.15\linewidth}| } \hline
    N. p. & \multicolumn{2}{p{0.15\linewidth}|}{Kierunek: $\circlearrowleft$} & \multicolumn{2}{p{0.15\linewidth}|}{Kierunek: $\circlearrowright$} \\ \hline
    - & $\in{x}$ & $\in{y}$ & $\in{x}$ & $\in{y}$ \\ \hline \hline
    1 & -28 & 5 & 62 & 28 \\ \hline
    2 & -33 & 15 & 54 & 32 \\ \hline
    3 & -2 & 4 & -45 & 9 \\ \hline
    4 & -5 & -21 & -55 & -19 \\ \hline
    5 & 13 & -12 & -31 & 27 \\ \hline
\end{tabular}
\end{table}

Mając do dyspozycji wartości potrzebnych pomiarów można przystąpić do obliczeń. Najpierw dla każdego kierunku należy wyznaczyć środek ciężkości, czyli uśrednić wartości współrzędnych $x$ i $y$, gdzie przykładowo dolny indeks $x_{cgcw}$ oznacza wartość współrzędnej $x$ środka ciężkości dla przejazdów zgodnych z ruchem wskazówek zegara (ang. \emph{cg - center of gravity}, \emph{cw - clockwise}). Analogicznie dla kierunku przeciwnego to będzie $x_{csccw}$. I tak:

\begin{center}
    $
    x_{cgccw} = \frac{1}{n}\sum_{i=1}^{n} (\in{x_{i,ccw}}) = \frac{-28-33-2-5+13}{5} = -11 \\[5pt]
    y_{cgccw} = \frac{1}{n}\sum_{i=1}^{n} (\in{y_{i,ccw}}) = \frac{5+15+4-21-12}{5} = -1,8 \\[5pt]
    x_{cgcw} = \frac{1}{n}\sum_{i=1}^{n} (\in{x_{i,cw}}) = \frac{62+54-45-55-31}{5} = -3 \\[5pt]
    y_{cgcw} = \frac{1}{n}\sum_{i=1}^{n} (\in{y_{i,cw}}) = \frac{28+32+9-19+27}{5} = 15,4
    $
\end{center}

W kolejnym kroku zostaną obliczone współczynniki $\alpha$ oraz $\beta$:

\begin{center}
    $
    \alpha = \frac{x_cgcw + x_cgccw}{-4L} = \frac{-3 - 11}{-4 \times 1,5} = 2,33^{\circ} \\[5pt] 
    \beta = \frac{x_cgcw - x_cgccw}{-4L} = \frac{-3 + 11}{-4 \times 1,5} = -1,33^{\circ}
    $
\end{center}

Z pomocą współczynników $\alpha$ i $\beta$ obliczane są błędy wylistowane poniżej. Tu należy zaznaczyć, że korekta dotyczy parametrów długości osi $b$ i średnicy kół $D$ schematu zastępczego robota przedstawionego wcześniej w niniejszym dokumencie na rysunku \ref{fig:odom-axis-simplified}.

\begin{itemize}
    \item Błąd $E_{d}$ będący stosunkiem średnicy koła prawego do koła lewego
    \item Błąd $E_{b}$ będący stosunkiem rzeczywistej długości osi do długości nominalnej
\end{itemize}

Obliczanie współczynników $E_{d}$ i $E_{b}$:

\begin{center}
    $
    R = \frac{L : 2}{sin(\beta : 2)} = \frac{1,5 : 2}{sin(-1,33 : 2)} = -0,01 \\[5pt]
    E_{d} = \frac{R + (b : 2)}{R - (b : 2)} = \frac{-0,01 + (b : 2)}{-0,01 - (b : 2)} \\[5pt]%%%%>TODOOOO
    E_{b} = \frac{90^{\circ}}{90^{\circ} - \alpha} = \frac{90^{\circ}}{90^{\circ} - 2,33^{\circ}} = 1,03
    $
\end{center}


%>TODO robot jezdzi dobrze nie ma potrzeby korekcji 
% wiec robot juz jezdzi wystarczajaco dobrze

\section{Skan otoczenia i budowa mapy}
\label{sec:scan}
Samo zebranie pomiarów i przedstawienie ich w formie czytelnej dla człowieka nie jest trudne w realizacji. Pozyskane dane można przedstawić na wykresie, punkty połączyć prostymi liniami. Problem zaczyna się z agregacją wielu pomiarów, i na tym będzie koncentrował się ten rozdział.

Mając do dyspozycji dane z sensora \emph{LIDAR} oraz enkoderów i magnetometru, można rozpocząć proces skanowania. Pierwsze podejście oparte było o skan manualny, bez zliczania ścieżki - jedynie obrót był uwzględniony a dane ze skanera obracane o zczytany z sensora azymut. Robot został ustawiony w początkowej pozycji, uruchomiono procedurę skanowania za pomocą funkcji \emph{SCAN}, następnie z racji że skan zachodzi w zakresie kątów $\langle0^{\circ},180^{\circ}\rangle$, obrócony o $180^{\circ}$ (funkcja \emph{ROTATE}) po czym ponownie wykonano skanowanie. Efekt przedstawia rysunek\ref{fig:first-scan}. Jak widać, ściany pokoju (górna i dolna część rysunku) nie są równoległe. W tym momencie okazało się, że konieczna będzie kalibracja magnetometru, omówiona w rozdziale \ref{sec:odometry}. Po dokonaniu procedury kalibracji czynności powtórzono, rezultat ukazano na rysunku \ref{fig:first-magnetom-calibrated-scan}. Na dalej przedstawianych rysunkach skany mogą wyglądać nieco inaczej, głównie przez zamknięte lub otwarte drzwi pokoju - widoczne jest to na ostatnich dwóch wspomnianych rysunkach jako najdłuższe z promieni - w tym wypadku drzwi były otwarte a pomiar uwzględniał fragment przedpokoju autora. Skany przedstawiane są w zakładce \emph{map} okna głównego aplikacji sterującej.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-01-room-map-nocalibration.png}
	\caption{Pierwszy skan pokoju}
	\label{fig:first-scan}
\end{figure}

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-02-room-map-calibrated.png}
	\caption{Skan pokoju po zastosowaniu kalibracji magnetometru}
	\label{fig:first-magnetom-calibrated-scan}
\end{figure}

W opisanych krokach dwa przeprowadzane pomiary były od siebie niezależne - mierzyły odległość od innych obiektów. Kolejnym krokiem było wykonanie kilku pomiarów częściowo nakładających się na siebie, co przedstawiają rysunki \ref{fig:overlapping-1}, \ref{fig:overlapping-2}, \ref{fig:overlapping-3} i \ref{fig:overlapping-4}. Szczególnie należy zwrócić uwagę na ostatni z nich - wyraźnie widać że ostatni skan absolutnie nie pokrywa się z poprzednimi. Najwyraźniej sama informacja o aktualnej rotacji robota nie jest wystarczająca aby dokładnie umieścić punkty na płaszczyźnie. 

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.5\linewidth]{rys/ScanBot-12-calibrated-room-map1.PNG}
	\caption{Skan pierwszy}
	\label{fig:overlapping-1}
\end{figure}

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.5\linewidth]{rys/ScanBot-12-calibrated-room-map2.PNG}
	\caption{Skan drugi}
	\label{fig:overlapping-2}
\end{figure}

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.5\linewidth]{rys/ScanBot-12-calibrated-room-map3.PNG}
	\caption{Skan trzeci}
	\label{fig:overlapping-3}
\end{figure}

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.5\linewidth]{rys/ScanBot-12-calibrated-room-map4.PNG}
	\caption{Skan czwarty}
	\label{fig:overlapping-4}
\end{figure}

W celu korekcji rzutowania punktów na płaszczyznę, pierwotnie stosowany był opracowany przez autora prosty, naiwny algorytm korygujący rotację. Jego działanie można opisać w kilku krokach:
\begin{enumerate}
    \item Na początku należy przeprowadzić pierwszy skan i zmierzyć azymut w którym skierowany jest robot.
    \item Następnie pomiary ze skanu (odległości w cm dla każdego z całkowitych wartości kątów w zakresie $\langle0^{\circ}, 180^{\circ}\rangle$) należy nanieść na wykres, uwzględniając rotację robota (dodając zmierzony azymut do wartości kątów przypisanych do każdego z pomiarów skanu).
    \item Potem przeprowadzany jest kolejny skan i pomiar azymutu.
    \item Do każdego z kątów pomiaru skanu dodawany jest azymut.
    \item W pętli, dla każdej z wartości $i$, gdzie $i={-10,-9,...,9,10}, i \in \mathbb{Z}$ do każdego z kątów dodawana jest wartość $i$ oraz sprawdzany i zapisywany jest parametr \emph{score} w sposób opisany w dalszej części dokumentu.
    \item Sprawdzane jest dla jakiego $i$ wartość parametru \emph{score} była największa. 
    \item Wyszukana wartość $i$ jest ostatecznie dodawana do wartości każdego z kątów pomiaru razem ze zmierzonym azymutem. Ta sama wartość jest dodawana do azymutu w którym skierowany jest robot - w ten sposób następuje jego korekcja. Kolejny pomiar i korekcja następuje od punktu 3 niniejszej listy.
\end{enumerate}

Listing \ref{lst:score-angle-correction} przedstawia fragment kodu przeprowadzający obliczanie współczynnika \emph{score}. Tutaj należy zaznaczyć, że ze względu na liczne zmiany w projekcie ten fragment nie zachował się w finalnej wersji kodu, można go natomiast podejrzeć na rezpozytorium w pliku \emph{src-pc/main.py} na gałęzi \emph{master} pod\emph{commit id} równym aba2c1510f1a661e6365f9cd4ca7dc782f013593.

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,language=python,caption=Obliczanie współczynnika \emph{score} i korekcja kąta w celu dopasowania pomiaru do mapy,label=lst:score-angle-correction]
def calc_xy_overlap_score(self, points1, points2):
    score = 0
    for point in points1:
        distance = self.find_xy_closest_point_distance(
            [point[0], point[1]], points2)
        # important! this way we're avoiding very high 1/distance value
        distance = int(distance)
        if distance == 0:
            score += 100
        elif distance >= 100:
            pass
        else:
            score += int((1/distance)*100)
    return score
\end{lstlisting}

Współczynnik \emph{score} obliczany jest na podstawie podobieństwa między pozycją punktów z najnowszego skanu względem tego, co już znajduje się na mapie. Aby móc skorzystać z powyższej funkcji poszczególne pomiary dla skanu są przeliczane z postaci biegunowej na kartezjańską. Następnie jest ona uruchamiana, a do parametrów \emph{points1} i \emph{points2} kolejno przekazywane są listy punktów nowego skanu i punktów znajdujących się na mapie. Następnie dla każdego z punktów skanu wykonywana jest operacja znalezienia najbliższego punktu na mapie i obliczenia odległości między nimi. Jeżeli punkty idealnie się pokrywają, do \emph{score} dodawana jest wartość 100. Jeżeli ta odległość wynosi więcej lub równo 100 centymetrów, nie dodawana jest żadna wartość. W zakresie $(1,100)$ do współczynnika jest dodawana wartość równa $\frac{1}{odległość}*100$, zaokrąglona do najbliższej liczby całkowitej. 

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,language=python,caption=Decyzja o zastosowaniu korekty,label=lst:score-threshold]
if score > 2500:
    print(
        f"adjusted plot and robot rotation by {best_rotation} degrees.")
    rotated_data = self.rotate_points(filtered_data, best_rotation)
    self.robot.update_azimuth(self.robot.azimuth + best_rotation)
else:
    rotated_data = filtered_data
\end{lstlisting}

Doświadczalnie został dobrany próg wartości \emph{score} równy 2500. Jeśli współczynnik dla najlepszej korekty kąta wynosi więcej niż próg, korekta zostanie zaakceptowana - azymut robota zostanie poprawiony, skan również będzie skorygowany i rzutowany na mapę. Obrazuje to listing \ref{lst:score-threshold}.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-13-angular-alignment-1yellow-2pink-3correctedgreen.PNG}
	\caption{Zobrazowana zasada działania korekcji kąta przy użyciu współczynnika \emph{score}}
	\label{fig:score-alignment-rule}
\end{figure}

Na rysunku \ref{fig:score-alignment-rule} przedstawiono działanie algorytmu korekcji kąta. Drugi ze skanów (punkty oznaczone kolorem żółtym) jest korygowany względem danych znajdujących się na mapie pochodzących ze skanu pierwszego (kolor różowy). Widoczne jest spore przesunięcie. Pomiar różowy dopasowywany był w zakresie  ±10°, osiągając maksymalną wartość\emph{score} przy -10°. Skorygowany pomiar został naniesiony na mapę z kolorem zielonym.

Ewaluacja tego algorytmu dla całego pokoju została ukazana na rysunkach \ref{fig:score-alignment-eval-1} i \ref{fig:score-alignment-eval-2}.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-14-angular-alignment.PNG}
	\caption{Pięć skanów otoczenia nałożonych z pomocą korekcji korzystającej ze współczynnika \emph{score}}
	\label{fig:score-alignment-eval-1}
\end{figure}

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/ScanBot-15-angular-alignment.PNG}
	\caption{Kolejne pięć skanów z korekcją kąta}
	\label{fig:score-alignment-eval-2}
\end{figure}

Pomimo iż algorytm działa i spełnia założone zadanie - problem \emph{SLAM} jest dużo bardziej złożony. Pierwotnie w planach autor planował wdrożenie podobnej korekcji dla translacji pojazdu oraz uśrednianie pozycji punktów na mapie. Jednak ze względu na dużą złożoność problemu i ograniczony czas autor zadecydował o skorzystaniu z istniejących rozwiązań. Pomocnym był tutaj zestaw narzędzi \emph{ROS}. Zawiera on wiele gotowych komponentów wykorzystywanych w robotyce, m. in. moduły adresujące problem \emph{SLAM}. Jednym z takich modułów jest \emph{slam\_gmapping} zawierający implementację algorytmu \emph{gmapping}\cite{Grisetti2005}\cite{gmapping-website}\cite{gmapping-ros}. Od tego momentu mapa sporządzana jest w środowisku \emph{ROS} i przedstawiana w programie \emph{RViz}. Finalna wersja aplikacji sterującej współpracuje ze środowiskiem publikując odpowiednie dane na wyznaczonych w tym celu tematach. Dokładniej obrazuje to schemat opisany w podrozdziale \ref{sec:pc-software}.

Kiedy całe środowisko zostało zestawione, przystąpiono do ręcznych testów jakości pracy platformy. Węzeł \emph{gmapping} uruchomiony został z parametrami domyślnymi. Już przy pierwszej ewaluacji (rysunek \ref{fig:mag-interference-first}) zauważono pewne nieprawidłowości. W tym momencie okazało się, że korzystanie z magnetometru przy odometrii nie było dobrym pomysłem. Pod podłogą prawdopodobnie w tym miejscu biegnie przewód elektryczny generując m. in. zmienne pole magnetyczne, zakłócając pracę magnetometru do takiego stopnia w którym odczytane dane są bezużyteczne i niemożliwe jest odtworzenie rzeczywistego pomiaru. Widoczne jest to w postaci bezładnie rozrzuconych punktów na górnmej części rysunku, promieniujących od punktu w którym znajduje się robot.
\\

\begin{figure}[ht]
	\centering
	    \includegraphics[width=0.6\linewidth]{rys/2020-11-04-170347_1920x1080_scrot.PNG}
	\caption{Mapa domu, uszkodzona na skutek interferencji magnetycznych}
	\label{fig:mag-interference-first}
\end{figure}

Aby zweryfikować przypuszczenia autor wykonał serię pomiarów za pomocą przycisku \emph{MEASURE [AUTO]} z zakładki \emph{magnetometer calibration}. To co zostało uwidocznione na rysunku \ref{fig:mag-interference-graph} z pewnością nie przypomina okręgu co potwierdza że w tym obszarze występują zakłócenia. Z tego powodu zmieniono sposób zliczania obrotu, co zostało opisane w rozdziale \ref{sec:odometry}.

\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\linewidth]{rys/calibrated-mag-high-interference-broken-rotation.PNG}
	\caption{Seria pomiarów ze skalibrowanego magnetometru w obszarze silnych zakłóceń}
	\label{fig:mag-interference-graph}
\end{figure}

Niestety, wykorzystując mniej dokładną metodę zliczania algorytm \emph{gmapping} również traci na jakości działania. Pomiar jest odporny na zakłócenia magnetyczne ale występuje problem przy wjeździe robota do nowych pomieszczeń. Nie mając wielu punktów odniesienia, z dużym błędem rotacji nowe pokoje są wyraźnie obrócone względem stanu rzeczywistego co przedstawia rysunek \ref{fig:encoder-only-run-first} na którym zaznaczono również kolejność skanowania pomieszczeń (1 - pokój autora, 2 - przedpokój, 3 - kuchnia, 4 - drugi pokój). Wpływa to bardzo negatywnie na późniejsze pomiary - mimo wszelkich starań nie udało się ukończyć skanu wszystkich pokojów.
\\

\begin{figure}[H]
	\centering
		\includegraphics[width=0.8\linewidth]{rys/saved-map-2-encoder-only-cropped-upscaled-path-withscale.png}
	\caption{Mapa domu, obrót zliczany za pomocą enkoderów}
	\label{fig:encoder-only-run-first}
\end{figure}

Ze względu na długi czas ewaluacji skanu całego domu oraz szybko kumulujący się błąd, w dalszej części obszar został zawężony jedynie do pokoju autora. Zaimplementowany również został algorytm samodzielnej jazdy robota, opisany w podrozdziale \ref{sec:autonomous-drive}.

Wyniki dwóch przejść robota po pomieszczeniu autora z wykorzystaniem autorskiego algorytmu jazdy autonomicznej przedstawiono na rysunkach \ref{fig:final-scans}.


\begin{figure}[H]
	\centering
		\includegraphics[width=0.8\linewidth]{rys/saved-map-final-1and2-cropped-upscaled-withscale.png}
	\caption{Mapa pomieszczenia powstała podczas jazdy autonomicznej robota}
    \label{fig:final-scans}
\end{figure}